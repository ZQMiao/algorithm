# LeetCode 26：删除有序数组中的重复项

**题目链接：**https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

**题目难度：**简单

**题目描述：**给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

## 1.暴力解法

类似数组 [1,2,2,3,4] 的数组。

1. 通过对数组从第0个位置进行遍历，如果 第 i 个位置的元素与第1+ 1 个位置的元素相同则将第 i+1 后面的元素整体向前移动一位，同时将数组长度减一。
2. 如果不相等则将指针向后移动。直到数组尾部为止。

代码实现如下：

```java
public int removeDuplicates(int[] nums) {
    /*
    1. 对数组进行遍历，对 i 和 i + 1 进行比较
    2. 如果两个数不相等则向后移动一位
    3.如果两个数相等则将i+1后面的数向前移动一位，并且将数组长度减一
     */
    int length = nums.length;
    for (int i = 0; i < length-1; ) {
        //1. 相邻两个数不相等则向后移动一位
        if (nums[i] != nums[i+1]) {
            i++;
        } else {
            //2.相邻的两个数相等，则进行移动数组
            for (int j = i+1; j < length -1; j++) {
                nums[j] = nums[j +1];
            }
            //数组长度减一
            length--;
        }
    }
    return length;
}
```

时间复杂度：O(n^2)

空间复杂度：O(1)





思考： 以上暴力解法是每次发现有重复元素后都进行移动数组后面的所有元素，但未必移动后的位置未必就是最终位置。那么是否一次性移动元素到目标位置？

## 2、双指针

分别记录移动元素和目标位置的索引

==**什么情况下使用双指针：**==

==**按照一定的规律同步发生变化，彼此影响的数据，可以采用双指针解法**==

**步骤**：

1.定义两个指针分别指向目标位和待移动元素为 ： 初始目标位为0 ，待移动元素位为1

2.比较两个指针对应的数据

- 比较相等：目标位不变，待移动为加1
- 比较不等： 目标位加1 ， 待移动元素复制到目标位；待移动位加1

细节问题：当目标位与待移动位相同，跳过赋值操作



```java
//定义两个指针一个目标指针，一个待移动指针
int target = 0;
//i相当于移动指针
for (int i = 1; i < nums.length; i++) {
    if (nums[target] != nums[i]) {
        //如果目标位和移动位不相等则进行 数据交换  出现 情况 如  1,2,2,3 时会出现相等的情况
        if (++target != i) {
            nums[target] = nums[i];
        }
    }
}
return target +1;
```

